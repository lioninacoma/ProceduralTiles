#pragma kernel CSMain

#include "SurfaceNets.cginc"
#include "MeshStructs.cginc"

#define THREAD_GROUP_SIZE_X 8
#define THREAD_GROUP_SIZE_Y 8
#define THREAD_GROUP_SIZE_Z 8

StructuredBuffer<float> _SignedDistanceField;

RWStructuredBuffer<Counts> _MeshCounts;
RWStructuredBuffer<ActiveCell> _ActiveCells;
RWStructuredBuffer<uint> _IndexCache;
RWStructuredBuffer<float3> _VertexBuffer;

uint _DataSize;
uint _CellSize;
uint _ChunkSize;
float3 _ChunkMin;

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, THREAD_GROUP_SIZE_Z)]
inline void CSMain (
        in uint3 _dispatchThreadID : SV_DispatchThreadID, // DispatchThreadID  = dot(GroupID, numthreads) + GroupThreadId;
        in uint  _groupIndex       : SV_GroupIndex, // uint GroupIndex = unique index of a thread inside a group
        in uint3 _groupID          : SV_GroupID, // GroupID = index for each dimension inside a ThreadGroupCount 
        in uint3 _groupThreadID    : SV_GroupThreadID // uint3 GroupThreadId = indices for each dimension inside a group of the current thread
    )
{
    uint3 cellPos = _dispatchThreadID;

    if (IsUpperBoundary(cellPos, _ChunkSize))
	{
		 return;
	}

    uint i, j, k;
	uint2 e;
	uint3 vi;
	float d;
	float3 p;
	float grid[8];
	uint mask = 0;
	
	for (i = 0; i < 8; i++)
	{
		vi = CUBE_VERTS[i] + cellPos;
		d = _SignedDistanceField[FI3(vi, _DataSize, _DataSize)];
		grid[i] = d;
		mask |= ((d > 0) ? (1 << i) : 0);
	}

	if (mask == 0 || mask == 0xff)
	{
		return;
	}

	uint edgeMask = EDGE_TABLE[mask];
	uint edgeCount = 0;

	float3 position = 0;
	float v[3];

	for (i = 0; i < 12; i++)
	{
		if ((edgeMask & (1 << i)) == 0)
		{
			continue;
		}

		e[0] = CUBE_EDGES[i << 1];
		e[1] = CUBE_EDGES[(i << 1) + 1];

		float g0 = grid[e[0]];
		float g1 = grid[e[1]];
		float t = g0 - g1;

		if (abs(t) > 1e-6)
		{
			t = g0 / t;
		}
		else
		{
			continue;
		}

		for (j = 0, k = 1; j < 3; j++, k <<= 1)
		{
			uint a = e[0] & k;
			uint b = e[1] & k;

			if (a != b)
			{
				v[j] = ((a > 0) ? 1.0 - t : t);
			}
			else
			{
				v[j] = ((a > 0) ? 1.0 : 0);
			}
		}

		p = cellPos + float3(v[0], v[1], v[2]);
		position += p;
		edgeCount++;
	}

	if (edgeCount == 0)
	{
		return;
	}

	float s = 1.0 / edgeCount;
	position = (s * position) * _CellSize;

	uint cellId = FI3(cellPos, _DataSize, _DataSize);
	ActiveCell activeCell = {mask, cellId};
	_ActiveCells[_ActiveCells.IncrementCounter()] = activeCell;

	uint index;
	InterlockedAdd(_MeshCounts[0].vertexCount, 1, index);
	
	_VertexBuffer[index] = position;

	uint m = GetM(cellPos, _DataSize);
	_IndexCache[m] = index;
}
